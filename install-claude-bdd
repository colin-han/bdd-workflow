#!/bin/bash

# Claude Code 命令模板安装脚本
# 用于将BDD Workflow命令模板复制到目标项目的.claude目录
# 使用方法: ./copy-to-claude.sh [目标项目目录]
# 如果不指定目标目录，将使用当前目录

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # 无颜色

# 获取脚本所在目录作为源目录（模板目录）
# 解析软链接，获取实际脚本文件路径
get_script_dir() {
    local script_path="${BASH_SOURCE[0]}"
    # 如果是软链接，解析到真实路径
    while [ -L "$script_path" ]; do
        script_path="$(readlink "$script_path")"
        # 如果readlink返回的是相对路径，需要基于当前目录计算
        if [[ "$script_path" != /* ]]; then
            script_path="$(dirname "${BASH_SOURCE[0]}")/$script_path"
        fi
    done
    # 返回脚本所在目录的绝对路径
    echo "$(cd "$(dirname "$script_path")" && pwd)"
}

SOURCE_DIR="$(get_script_dir)"

# 获取目标项目目录，默认为当前工作目录
if [ $# -eq 0 ]; then
    TARGET_DIR="$(pwd)"
else
    TARGET_DIR="$1"
fi

# 转换为绝对路径（兼容macOS）
get_absolute_path() {
    local path="$1"
    if [[ "$path" = /* ]]; then
        echo "$path"
    else
        echo "$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
    fi
}

TARGET_DIR="$(get_absolute_path "$TARGET_DIR")"
CLAUDE_DIR="$TARGET_DIR/.claude"

echo -e "${BLUE}=== Claude Code 命令模板安装工具 ===${NC}"
echo -e "源目录: ${GREEN}$SOURCE_DIR${NC}"
echo -e "目标目录: ${GREEN}$CLAUDE_DIR${NC}"
echo

# 检查目标目录是否存在
if [ ! -d "$TARGET_DIR" ]; then
    echo -e "${RED}错误：目标目录 '$TARGET_DIR' 不存在${NC}"
    exit 1
fi

# 收集所有要复制的文件（排除.claude目录和脚本本身）
collect_files() {
    find "$SOURCE_DIR" -type f \
        ! -path "*/.claude/*" \
        ! -name "copy-to-claude.sh" \
        ! -name "install-claude-bdd" \
        ! -name "README.md" \
        ! -name "LICENSE" \
        ! -path "*/.git/*" \
        ! -name ".DS_Store" \
        | sort
}

# 生成文件树结构
print_file_tree() {
    local conflicts_temp_file="/tmp/conflicts_$$"
    local all_files=()
    
    # 收集所有文件和冲突信息
    : > "$conflicts_temp_file"
    while IFS= read -r file; do
        local rel_path="${file#$SOURCE_DIR/}"
        all_files+=("$rel_path")
        local target_file="$CLAUDE_DIR/$rel_path"
        
        if [ -f "$target_file" ] && ! files_are_identical "$file" "$target_file"; then
            echo "$rel_path" >> "$conflicts_temp_file"
        fi
    done < <(collect_files)
    
    # 简化的树形结构显示
    echo -e "${BLUE}将要复制的文件树：${NC}"
    
    # 按目录分组显示
    local current_dir=""
    for file in "${all_files[@]}"; do
        local dir_path="$(dirname "$file")"
        local file_name="$(basename "$file")"
        
        # 检查是否是冲突文件
        local is_conflict=0
        if grep -q "^$file$" "$conflicts_temp_file" 2>/dev/null; then
            is_conflict=1
        fi
        
        # 如果目录改变，显示目录
        if [[ "$dir_path" != "$current_dir" ]]; then
            if [[ "$dir_path" != "." ]]; then
                echo -e "├── ${BLUE}$dir_path/${NC}"
                current_dir="$dir_path"
            else
                current_dir="."
            fi
        fi
        
        # 显示文件
        local target_file="$CLAUDE_DIR/$file"
        if [[ "$dir_path" != "." ]]; then
            if [[ "$is_conflict" -eq 1 ]]; then
                echo -e "│   ├── ${RED}$file_name${NC} ${YELLOW}(将被更新)${NC}"
            elif [[ ! -f "$target_file" ]]; then
                echo -e "│   ├── ${GREEN}$file_name${NC} ${BLUE}(新文件)${NC}"
            else
                echo -e "│   ├── ${GREEN}$file_name${NC}"
            fi
        else
            if [[ "$is_conflict" -eq 1 ]]; then
                echo -e "├── ${RED}$file_name${NC} ${YELLOW}(将被更新)${NC}"
            elif [[ ! -f "$target_file" ]]; then
                echo -e "├── ${GREEN}$file_name${NC} ${BLUE}(新文件)${NC}"
            else
                echo -e "├── ${GREEN}$file_name${NC}"
            fi
        fi
    done
    echo
    
    # 清理临时文件
    rm -f "$conflicts_temp_file"
}

# 检查两个文件是否相同
files_are_identical() {
    local file1="$1"
    local file2="$2"
    
    if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
        return 1
    fi
    
    # 使用diff检查文件是否相同，静默输出
    diff -q "$file1" "$file2" >/dev/null 2>&1
}

# 检查冲突文件并列出所有文件
check_conflicts() {
    local has_conflicts=0
    
    # 显示文件树
    print_file_tree
    
    # 检查是否有真正的冲突（文件存在且内容不同）
    while IFS= read -r file; do
        local rel_path="${file#$SOURCE_DIR/}"
        local target_file="$CLAUDE_DIR/$rel_path"
        
        if [ -f "$target_file" ] && ! files_are_identical "$file" "$target_file"; then
            has_conflicts=1
            break
        fi
    done < <(collect_files)
    
    if [ "$has_conflicts" -eq 1 ]; then
        echo -e "${YELLOW}注意：标记为 ${RED}红色${YELLOW} 的文件将被更新${NC}"
        echo
        return 1
    else
        echo -e "${GREEN}未发现文件冲突${NC}"
        echo
    fi
    
    return 0
}

# 用户确认函数
confirm_operation() {
    local has_conflicts=$1
    
    if [ "$has_conflicts" -eq 1 ]; then
        echo -e "${YELLOW}警告：存在文件差异，继续操作将更新目标文件。${NC}"
    else
        echo -e "${GREEN}未发现文件冲突。${NC}"
    fi
    
    echo -e "是否继续复制操作？ ${BLUE}[y/N]${NC}"
    read -r response
    
    case "$response" in
        [yY]|[yY][eE][sS])
            return 0
            ;;
        *)
            echo -e "${YELLOW}操作已取消${NC}"
            exit 0
            ;;
    esac
}

# 执行复制操作
copy_files() {
    local copied_count=0
    local total_count=0
    
    # 创建.claude目录
    mkdir -p "$CLAUDE_DIR"
    
    # 统计总文件数
    total_count=$(collect_files | wc -l)
    
    echo -e "${BLUE}开始复制文件...${NC}"
    
    while IFS= read -r file; do
        local rel_path="${file#$SOURCE_DIR/}"
        local target_file="$CLAUDE_DIR/$rel_path"
        local target_dir="$(dirname "$target_file")"
        
        # 创建目标目录
        mkdir -p "$target_dir"
        
        # 复制文件
        if cp "$file" "$target_file"; then
            ((copied_count++))
            echo -e "  ${GREEN}✓${NC} $rel_path"
        else
            echo -e "  ${RED}✗${NC} 复制失败: $rel_path"
        fi
    done < <(collect_files)
    
    echo
    echo -e "${GREEN}复制完成！${NC}"
    echo -e "成功复制 ${GREEN}$copied_count${NC} / ${BLUE}$total_count${NC} 个文件到 ${GREEN}$CLAUDE_DIR${NC}"
}

# 主程序
main() {
    # 检查是否有文件需要复制
    if [ "$(collect_files | wc -l)" -eq 0 ]; then
        echo -e "${YELLOW}未找到需要复制的文件${NC}"
        exit 0
    fi
    
    # 检查是否所有文件都已存在且相同
    local has_new_or_different=0
    while IFS= read -r file; do
        local rel_path="${file#$SOURCE_DIR/}"
        local target_file="$CLAUDE_DIR/$rel_path"
        
        if [ ! -f "$target_file" ] || ! files_are_identical "$file" "$target_file"; then
            has_new_or_different=1
            break
        fi
    done < <(collect_files)
    
    # 如果所有文件都相同，直接退出
    if [ "$has_new_or_different" -eq 0 ]; then
        echo -e "${GREEN}所有文件都已存在且相同，无需复制。${NC}"
        exit 0
    fi
    
    # 检查冲突
    local has_conflicts=0
    if ! check_conflicts; then
        has_conflicts=1
    fi
    
    # 用户确认
    confirm_operation $has_conflicts
    
    # 执行复制
    copy_files
}

# 执行主程序
main